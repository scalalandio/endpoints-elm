{-
  This file was generated by endpoints-elm interpreter.
  Do not edit this file manually.

  See https://github.com/scalalandio/endpoints-elm for more information.
-}

module Data.DateCase exposing (..)

import Date exposing (..)
import Json.Decode as Decode exposing (Decoder)
import Json.Decode.Pipeline exposing (optional, required)
import Json.Encode as Encode


type alias DateCase = 
  { value : Date
  , msg : String
  }

init : DateCase
init = 
  { value = Date.fromOrdinalDate 1970 1
  , msg = ""
  }

decoder : Decoder DateCase
decoder = Decode.succeed DateCase
  |> required "value" (Decode.string |> Decode.andThen (Date.fromIsoString >> Result.map Decode.succeed >> Result.withDefault (Decode.fail "can't parse the date!"))) 
  |> required "msg" Decode.string 

encoder : DateCase -> Encode.Value
encoder model = Encode.object (fieldsEncoder model)

encoderTagged : (String, String) -> DateCase -> Encode.Value
encoderTagged (discriminator, tag) model = Encode.object ((discriminator, Encode.string tag) :: fieldsEncoder model)

fieldsEncoder : DateCase -> List (String, Encode.Value)
fieldsEncoder model = 
  [ ( "value", (Encode.string << Date.toIsoString) model.value )
  , ( "msg", Encode.string model.msg )
  ]

setValue : Date -> DateCase -> DateCase
setValue newValue dateCase =
  { dateCase | value = newValue }

setMsg : String -> DateCase -> DateCase
setMsg newMsg dateCase =
  { dateCase | msg = newMsg }


updateValue : (Date -> Date) -> DateCase -> DateCase
updateValue f dateCase =
  { dateCase | value = f dateCase.value }

updateMsg : (String -> String) -> DateCase -> DateCase
updateMsg f dateCase =
  { dateCase | msg = f dateCase.msg }
